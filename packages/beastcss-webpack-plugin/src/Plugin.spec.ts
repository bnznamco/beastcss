import path from 'path';
import * as fs from 'fs';
import { Volume, vol } from 'memfs';
import { type IUnionFs, ufs } from 'unionfs';
import webpack, { type Configuration } from 'webpack';
import MiniCssExtractPlugin from 'mini-css-extract-plugin';
import HtmlWebpackPlugin from 'html-webpack-plugin';
import Beastcss from 'beastcss';

import Plugin from './Plugin';

function getWebpackConfig(includeHtmlWebpackPlugin = true) {
  const config = {
    mode: 'none',
    context: path.resolve('./'),
    target: 'node',
    entry: {
      main: path.resolve('./index.js'),
    },
    output: {
      filename: '[name].js',
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: '[name].css',
      }),
    ],
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: [
            MiniCssExtractPlugin.loader,
            path.resolve(__dirname, '../node_modules/css-loader'),
          ],
        },
        {
          test: /index\.html$/i,
          type: 'asset/resource',
          generator: {
            filename: '[name][ext]',
          },
        },
      ],
    },
    optimization: {
      minimize: false,
    },
  } as Configuration;

  if (includeHtmlWebpackPlugin) {
    config.plugins?.unshift(
      new HtmlWebpackPlugin({
        filename: 'index2.html',
        templateContent: '<h1>Hello World!</h1><p>This is a paragraph</p>',
      })
    );
  }

  return config;
}

async function compile(
  config: Configuration,
  beastcssOptions?: Partial<Beastcss.Options>
): Promise<void> {
  config.plugins?.push(new Plugin(beastcssOptions));

  const compiler = webpack(config);

  compiler.inputFileSystem = ufs.use(fs).use(vol as unknown as IUnionFs);
  compiler.intermediateFileSystem = vol;
  compiler.outputFileSystem = vol;

  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      if (err) {
        return reject(err);
      }

      const info = stats?.toJson({ all: false, errors: true, warnings: true });

      if (stats?.hasErrors()) {
        // eslint-disable-next-line no-console
        console.error(info?.errors);

        return reject(
          new Error('Webpack compilation has errors. See log above.')
        );
      }

      if (stats?.hasWarnings()) {
        // eslint-disable-next-line no-console
        console.warn(info?.warnings);
      }

      return compiler.close(() => {
        resolve();
      });
    });
  });
}

describe('Beastcss Webpack Plugin', () => {
  afterEach(() => {
    vol.reset();
  });

  describe('Basic Usage', () => {
    let html: string;
    let html2: string;

    beforeAll(async () => {
      vol.fromJSON({
        './index.html': [
          '<link rel="stylesheet" href="/main.css">',
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './style.css': [
          'h1 { color: blue; }',
          'h2.unused { color: red; }',
          'p { color: purple; }',
          'p.unused { color: orange; }',
        ].join('\n'),
        './index.js': `import './index.html'; import './style.css';`,
      });

      await compile(getWebpackConfig(), { logLevel: 'silent' });

      html = (
        await vol.promises.readFile('./dist/index.html', 'utf-8')
      ).toString();

      // generated by html-webpack-plugin
      html2 = (
        await vol.promises.readFile('./dist/index2.html', 'utf-8')
      ).toString();
    });

    it('should insert critical css from external stylesheet', () => {
      expect(html).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');
      expect(html2).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');
    });

    it('should make external stylesheet loading async', () => {
      expect(html).toMatch(
        `<link rel="stylesheet" href="/main.css" media="print" onload="this.media='all'; this.onload=null;">`
      );
      expect(html2).toMatch(
        `<link href="main.css" rel="stylesheet" media="print" onload="this.media='all'; this.onload=null;">`
      );
    });
  });

  describe('additionalStylesheets option', () => {
    it('should insert critical css from additional stylesheets', async () => {
      vol.fromJSON({
        './index.html': [
          '<head><link rel="stylesheet" href="/main.css"></head>',
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './style.css': [
          'h1 { color: blue; }',
          'h2.unused { color: red; }',
        ].join('\n'),
        './additional.css': 'p { background-color: yellow; }',
        './additional2.css': 'p { color: green; } p.unused { color: red; }',
        './index.js': `import './index.html'; import './style.css';`,
        './additional.js': `import './additional.css';`,
      });

      const config = getWebpackConfig();

      config.entry = {
        ...(config.entry as webpack.EntryObject),
        additional: path.resolve('./additional.js'),
      };

      await compile(config, {
        logLevel: 'silent',
        additionalStylesheets: ['additional.css', '../additional2.css'],
      });

      const html = (
        await vol.promises.readFile('./dist/index.html', 'utf-8')
      ).toString();

      // generated by html-webpack-plugin
      const html2 = (
        await vol.promises.readFile('./dist/index2.html', 'utf-8')
      ).toString();

      expect(html).toMatch(
        '<style>h1{color: blue;}p{background-color: yellow;}p{color: green;}</style>'
      );

      expect(html2).toMatch(
        '<style>h1{color: blue;}p{background-color: yellow;}p{color: green;}</style>'
      );
    });
  });

  describe('Custom publicPath webpack option', () => {
    it('should insert critical css from external stylesheet', async () => {
      vol.fromJSON({
        './index.html': [
          '<link rel="stylesheet" href="/_public/main.css">',
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './style.css': [
          'h1 { color: blue; }',
          'h2.unused { color: red; }',
          'p { color: purple; }',
          'p.unused { color: orange; }',
        ].join('\n'),
        './index.js': `import './index.html'; import './style.css';`,
      });

      const webpackConfig = getWebpackConfig();
      if (webpackConfig.output) {
        webpackConfig.output.publicPath = () => '/_public/';
      }

      await compile(webpackConfig, { logLevel: 'silent' });

      const html = (
        await vol.promises.readFile('./dist/index.html', 'utf-8')
      ).toString();

      // generated by html-webpack-plugin
      const html2 = (
        await vol.promises.readFile('./dist/index.html', 'utf-8')
      ).toString();

      expect(html).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');

      expect(html2).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');
    });
  });

  describe('Fallback to file system', () => {
    it('should insert critical css from external stylesheet', async () => {
      const htmlTemplate = [
        '<link rel="stylesheet" href="/style.css">',
        '<h1>Hello World!</h1>',
        '<h2>A title</h2>',
        '<p>This is a paragraph</p>',
      ].join('\n');

      const customVol = Volume.fromJSON({
        './dist/style.css': [
          'h1 { color: blue; }',
          'h2.unused { color: red; }',
          'p { color: purple; }',
          'p.unused { color: orange; }',
        ].join('\n'),
      });

      vol.fromJSON({
        './index.html': htmlTemplate,
        './index.js': `import './index.html';`,
      });

      const config = getWebpackConfig();

      config.plugins = config.plugins || [];
      config.plugins[0] = new HtmlWebpackPlugin({
        filename: 'index2.html',
        templateContent: htmlTemplate,
      });

      await compile(config, {
        logLevel: 'silent',
        fs: customVol as unknown as Beastcss.FSLike,
        pruneSource: true,
      });

      const html = (
        await vol.promises.readFile('./dist/index.html', 'utf-8')
      ).toString();

      // generated by html-webpack-plugin
      const html2 = (
        await vol.promises.readFile('./dist/index2.html', 'utf-8')
      ).toString();

      expect(html).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');
      expect(html2).toMatch('<style>h1{color: blue;}p{color: purple;}</style>');
    });

    it('should remove external stylesheet totally pruned', async () => {
      const htmlTemplate = [
        '<link rel="stylesheet" href="/style.css">',
        '<h1>Hello World!</h1>',
        '<p>This is a paragraph</p>',
      ].join('\n');

      const customVol = Volume.fromJSON({
        './dist/style.css': [
          'h1 { color: blue; }',
          'p { color: purple; }',
        ].join('\n'),
      });

      vol.fromJSON({
        './index.html': htmlTemplate,
        './index.js': `import './index.html';`,
      });

      const config = getWebpackConfig();

      config.plugins = config.plugins || [];
      config.plugins[0] = new HtmlWebpackPlugin({
        filename: 'index2.html',
        templateContent: htmlTemplate,
      });

      await compile(config, {
        logLevel: 'silent',
        fs: customVol as unknown as Beastcss.FSLike,
        pruneSource: true,
      });

      const files = await vol.promises.readdir('./dist');

      expect(files).not.toContain('main.css');
    });
  });

  describe('pruneSource option enabled', () => {
    it('should prune external stylesheet', async () => {
      vol.fromJSON({
        './index.html': [
          '<link rel="stylesheet" href="/main.css">',
          '<h1>Hello World!</h1>',
          '<h2>A title</h2>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './style.css': [
          'h1 { color: blue; }',
          'h2.unused { color: red; }',
          'p { color: purple; }',
          'p.unused { color: orange; }',
        ].join('\n'),
        './index.js': `import './index.html'; import './style.css';`,
      });

      await compile(getWebpackConfig(), {
        logLevel: 'silent',
        pruneSource: true,
      });

      const prunedStylesheet = await vol.promises.readFile(
        './dist/main.css',
        'utf8'
      );

      expect(prunedStylesheet).toMatch('p.unused{color: orange;}');
    });

    it('should remove external stylesheet totally pruned', async () => {
      vol.fromJSON({
        './index.html': [
          '<link rel="stylesheet" href="/main.css">',
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './style.css': ['h1 { color: blue; }', 'p { color: purple; }'].join(
          '\n'
        ),
        './index.js': `import './index.html'; import './style.css';`,
      });

      await compile(getWebpackConfig(), {
        logLevel: 'silent',
        pruneSource: true,
      });

      const files = await vol.promises.readdir('./dist');

      expect(files).not.toContain('main.css');
    });
  });

  describe('Custom logger', () => {
    let spyInfo: jest.SpyInstance;

    beforeAll(() => {
      spyInfo = jest.spyOn(console, 'info').mockImplementation();
    });

    afterAll(() => {
      jest.restoreAllMocks();
    });

    afterEach(() => {
      jest.resetAllMocks();
    });

    it('should support custom logger', async () => {
      vol.fromJSON({
        './index.js': '',
      });

      await compile(getWebpackConfig(), {
        logLevel: 'info',
        logger: console,
      });

      expect(spyInfo.mock.results).toHaveLength(1);
    });
  });

  describe('Debugs logging', () => {
    let spyDebug: jest.SpyInstance;
    let config: webpack.Configuration;

    afterAll(() => {
      jest.restoreAllMocks();
    });

    beforeEach(() => {
      config = getWebpackConfig(false);

      config.plugins?.push({
        apply: (compiler) => {
          const getLogger = compiler.getInfrastructureLogger.bind(compiler);

          compiler.getInfrastructureLogger = jest.fn((name) => {
            const logger = getLogger(name);

            if (name === Plugin.name) {
              jest.spyOn(logger, 'info').mockImplementation();
              spyDebug = jest.spyOn(logger, 'debug').mockImplementation();
            }

            return logger;
          });
        },
      });

      config.plugins = config.plugins?.filter(
        ({ name }) => name !== HtmlWebpackPlugin.name
      );
    });

    afterEach(() => {
      jest.resetAllMocks();
    });

    it('should output debug message when additional stylesheet is excluded', async () => {
      vol.fromJSON({
        './index.html': [
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './additional.css': 'p { background-color: yellow; }',
        './additional.js': "import './additional.css';",
        './index.js': `import './index.html';`,
      });

      config.entry = {
        ...(config.entry as webpack.EntryObject),
        additional: path.resolve('./additional.js'),
      };

      await compile(config, {
        logLevel: 'debug',
        additionalStylesheets: ['additional.css'],
        exclude: /additional\.css/,
      });

      expect(spyDebug.mock.results).toHaveLength(1);
      expect((spyDebug.mock.calls[0] as string[])[0]).toMatch(
        'Excluded additional stylesheet'
      );
    });
  });

  describe('Warnings logging', () => {
    let spyWarn: jest.SpyInstance;
    let config: webpack.Configuration;

    afterAll(() => {
      jest.restoreAllMocks();
    });

    beforeEach(() => {
      config = getWebpackConfig(false);

      config.plugins?.push({
        apply: (compiler) => {
          const getLogger = compiler.getInfrastructureLogger.bind(compiler);

          compiler.getInfrastructureLogger = jest.fn((name) => {
            const logger = getLogger(name);

            if (name === Plugin.name) {
              jest.spyOn(logger, 'info').mockImplementation();
              spyWarn = jest.spyOn(logger, 'warn').mockImplementation();
            }

            return logger;
          });
        },
      });

      config.plugins = config.plugins?.filter(
        ({ name }) => name !== HtmlWebpackPlugin.name
      );
    });

    afterEach(() => {
      jest.resetAllMocks();
    });

    it('should output warning message if external stylesheet is not found', async () => {
      vol.fromJSON({
        './index.html': [
          '<link rel="stylesheet" href="/unvailable.css">',
          '<h1>Hello World!</h1>',
          '<p>This is a paragraph</p>',
        ].join('\n'),
        './index.js': `import './index.html';`,
      });

      await compile(config);

      expect(spyWarn.mock.results).toHaveLength(1);
      expect((spyWarn.mock.calls[0] as string[])[0]).toMatch(
        /External stylesheet ".*" not found\./
      );
    });

    it('should output warning message if unable to find HTML asset', async () => {
      vol.fromJSON({
        './index.js': ``,
      });

      await compile(config);

      expect(spyWarn.mock.results).toHaveLength(1);
      expect((spyWarn.mock.calls[0] as string[])[0]).toMatch(
        /Unable to find any HTML asset/
      );
    });

    it('should output warning message if HTML asset is empty', async () => {
      vol.fromJSON({
        './index.html': '',
        './index.js': `import './index.html';`,
      });

      await compile(config);

      expect(spyWarn.mock.results).toHaveLength(1);
      expect((spyWarn.mock.calls[0] as string[])[0]).toMatch(
        /Empty HTML asset/
      );
    });
  });
});
